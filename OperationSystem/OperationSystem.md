# OS

1. 共享和并发是两个最基本的特征，并相互依存。
2. 并发的关键是进程之间的切换

## 程序并发
 宏观上是并发执行，微观上是多程序交替执行
 
## 进程（哈哈哈哈正在进行的程序）

三个状态：
1. 执行： 。。。
2. 阻塞： 等待资源或者I/O之类的。
3. 就绪： 获得执行条件，但是缺少处理机调度。

三个组成部分：
1. 程序： 自己对应的程序
2. 数据集合： 运行所需要的数据
3. PCB： （Process control Block）进程控制块。操作系统用于对进程的控制和管理。

### PCB

1. 进程标识符
   1. 内部标识符：如PID
   2. 外部表示符：wechat之类的名字
   3. 家族关系： 父子进程 
2. 处理机状态信息
   1. 当进程被处理机中断时，保存进程运行时产生并保存在寄存器的数据。
   2. 这组寄存器包括：基础寄存器，指令寄存器，程序状态字，用户堆栈指针
3. 进程调度信息
   1. 程序状态 ： 指明进程当前状态
   2. 进程优先级： 。。。
   3. 进程调度所需的资源： 。。。
   4. 事件： 进程阻塞的原因
4. 进程控制信息
   1. 进程和数据地址： 进程程序和数据所在的内存和外存地址
   2. 进程同步和通信机制 ：实现进程同步和进程通信时所必须的机制，如消息队列指针，信号量
   3. 资源清单 ： 所需和已分配的资源
   4. 链接指针 ： 本进程在就绪或阻塞队列中的PCB首地址

#### PCB队列
单 `cpu` 一次只能执行  一个进程。其他进程处于阻塞或就绪状态。用 `链表` 将这些程序的 `PCB` 链接起来。（对应上面的链接指针）。
并有`就绪队列`和`阻塞队列`之分。

### 进程调度
三级调度：`低级调度一定存在`
1. 高级调度 ： 决定把哪些程序从外存放入内存，并分配`内存` 和 `I/O` 资源
2. 中级调度 ： 当`内存` 空间不足时，把`就绪`或`阻塞`的进程交换到外存。反之则调入内存。
3. 低级调度 ： 选择`就绪`状态的进程放进`cpu`执行。（最频繁）

两种处理方式：
1. 抢占式：强行抢占
2. 非抢占式：。。。

调度算法：
1. 先来先服务 ： `按正常先后秩序，正常结束或者等待资源主动让出cpu`。**对短作业不公平**。因为短作业等的时间太长了，就执行那么一哈儿。找片半小时……
2. 时间片轮转 ： `算法分配固定时间片，用完就就绪或者阻塞。用户请求的作业也可分配高优先级`
3. 优先级 ： `进程分优先级，相同优先级则先来先服务` 
4. 多级任务队列 ： `要的越多等待地越久`

进程调度程序的功能：
1. 记录所有进程的相关信息，比如优先级，当前状态。
2. 确定分配算法
3. 分配处理机
4. 回收处理机

### 使用`原语`保证`创建进程`,`撤销进程`,`阻塞进程`,`唤醒进程`
步骤：
1. 关闭中断
2. 一系列操作
3. 打开中断

### JCB (job control block)
`作业控制块`：有自己的作业队列。只有通过`高级调度`把作业放在内存里，才参与与其他进程`竞争cpu`

三个状态：
1. 提交状态： 在`辅助存储器`
2. 后备状态： 高级调度到内存，并参与cpu竞争
3. 运行状态： 。。。
4. 完成状态： 撤销作业，回收资源，撤除JCB

作业调度算法：`注意审题是什么调度算法`
1. 周转时间： 完成时间 - 到达时间 `完成时间 = 到达时间 + 等待时间 + cpu占用时间 `
2. 平均周转时间： (n个周转时间之和)➗n
3. 加权周转时间: cpu占用时间➗周转时间
4. 平均加权周转时间：(n个加权周转时间之和)➗n


