# 事务

## 隔离性
### 查看默认的隔离级别
```shell
SELECT @@SESSION.tx_isolation;
```
默认是 REPEATABLE-READ
```txt
意思可重复读
```

### 读未提交
```txt
能够读取到未提交的数据。可能回导致脏读，不可重复度，幻读
```
### 读已提交
```txt
保证事务读取到已经提交的数据，解决了脏读。

[未解决不可重复度]：在事务的过程中，如果有其他事务对数据进行了修改，仍然会导致多次读取的数据不一致。

[未解决幻读]：
```
### 可重复读
```txt
在同一事务中，多次读取的数据是一致的。
[怎么解决不可重复读的：事务开始时，创建一个数据快照，防止其他事务修改影响当前事务。
[未解决幻读]：就是因为事务开始时创建了数据快照，导致其他事务新增、删除数据，不会被查询到。但是在事务的多次查询中似乎出现了新数据，就像幻觉一样。
```
### 串行化
```txt
解决了所有的包括 脏读，不可重复读，幻读 问题。缺点并发能力无了。
所有事务都是串行。
最高级别的隔离。
```

### 根据事务提出的一些问题和答案

1. 为什么可重复度还是不能解决幻读  
   &emsp;**不可重复读(Non-Repeatable Read):** 这个问题指的是在`同一个事务内`，多次读取同一数据，得到的结果不一致。在`“可重复读”`隔离级别下，通过创建`数据快照`来确保事务内多次读取的一致性，避免了不可重复读问题。  
   &emsp;**幻读(Phantom Read)** 这个问题涉及到在同一事务内多次执行查询，结果集中的行数发生了变化，似乎出现了新的数据行。即使使用“可重复 读”隔离级别，因为只是创建了数据快照而没有锁定查询范围，其他事务仍然可以在事务执行过程中插入或删除数据，导致幻读问题。  
   &emsp;决幻读问题需要更严格的控制，而“串行化”隔离级别在这方面提供了解决方案。在“串行化”隔离级别下，会对查询的范围进行锁定，确保在事务执行期间其他事务不能插入或删除相关数据，从而避免了幻读问题。但是，串行化隔离级别会严重影响并发性能，因为它限制了多个事务之间的并发执行。  
   &emsp;因此，尽管“可重复读”隔离级别在某些情况下能够减少幻读问题，但如果要完全消除幻读问题，可能需要使用更高代价的隔离级别，如“串行化”。选择隔离级别时需要权衡数据一致性和并发性能。  

2. 可重复读的事务隔离级别，首次查询的时候生成数据快照，然后后面的每次查询都以这个数据快照为准，所以新插入的数据或者新删除的数据不会被查询出来？这个就是幻读。是这个意思吗   
   &emsp;是的，你理解得很正确。在可重复读（REPEATABLE READ）事务隔离级别下，事务在第一次执行查询时会创建一个数据快照，然后后续的每次查询都会使用这个数据快照作为参考，以确保在同一事务内多次读取相同数据时能够得到一致的结果。这就是为什么叫做“可重复读”，因为同一事务内的多次读取会重复地得到相同的数据。  
   &emsp;而，幻读问题并不是因为新插入的数据或删除的数据被查询出来了。幻读问题是指，在可重复读事务隔离级别下，事务在第一次查询时创建了数据快照，然后在事务执行期间，其他事务插入了新数据行（或删除了数据行），这些新数据行在当前事务的数据快照中是看不到的。然而，当当前事务再次执行相同的查询时，它会发现似乎有一些之前不存在的数据行（幻行）出现了，这就是幻读问题。  
   &emsp;所以，你的理解是正确的：幻读问题在可重复读事务隔离级别下出现，是因为数据快照导致事务看不到其他事务插入的新数据行，但在事务的多次查询中，似乎出现了新的数据行，就像是幻觉一样，因此称为幻读。

   
## 一致性

## 原子性

## 持久性
永久保存