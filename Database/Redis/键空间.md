### 键空间
```text
本质： 还是订阅发布
目的： 为了减少数据库I/O，批量写入数据
```
看下php代码：

```php
<?php
const select1 = 6;
function redis_conn() {
    // 具体细节不必多说
    return (new \Redis())->connect('127.0.0.1');
}
$redis = redis_conn();// redis 连接就不必细说

/**
 * Subscribe to channels by pattern
 *
 * @param array                 $patterns an array of glob-style patterns to subscribe
 * @param string|array|callable $callback Either a string or an array with an object and method.
 *                     The callback will get four arguments ($redis, $pattern, $channel, $message)
 * @return mixed|Redis Any non-null return value in the callback will be returned to the caller or Redis if in multimode
 *
 * @throws RedisException
 *
 * @link    https://redis.io/commands/psubscribe
 * @example
 * <pre>
 * function f($redis, $pattern, $chan, $msg) {
 *  echo "Pattern: $pattern\n";
 *  echo "Channel: $chan\n";
 *  echo "Payload: $msg\n";
 * }
 *
 * $redis->psubscribe(array('chan-1', 'chan-2', 'chan-3'), 'f')
 * </pre>
 */
$call_back = function($redis, $pattern, $chan, $msg){
    // 需要注意的是，这里不能复用外部redis的连接，因为redis连接会被下面的psubcript占用，导致不可用
    // 这里注意要用try—catch捕获异常，不然出错就会导致服务不可用
    try {
        $redis2 = redis_conn();
        // 这里的重点是，在设置键的时候，要注意，保存数据的键要比监听的键ttl时间长一点
        // 而且要注意判断key和值
        // 这里搞成事件监听，方便一点
    }catch (\Throwable $th){
    
    }finally {
       // do something ...
    }
};
// 这里相当于是订阅了这个库里面的键消失，然后就会触发call_back这个方法
$redis->psubscript([
    '__keyevent@' . select1 . '__:expired',
    '__keyevent@' . select1 . '__:del',
],$call_back);
```


### id_pool redis简单版
```text
本质： 不让他id自增，让直接冲id池里面取
目的： 一个完整的数据被拆分装到多张表里，关联是其中的某一张表的自增id
```
看下代码
```php
<?php
// 关键代码就一句，避免高并发取到同一个id
// https://redis.io/commands/blpop/
$res = (new \Redis)->connect('127.0.0.1')->blpop($key);

// 其他的设计无非就是，workerman 定时任务跑一跑id池剩余的id，然后达不到预期就rpop为开始，生成一批
```